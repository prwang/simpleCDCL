c pigeon-3: placing 4 pigeons into 3 holes
c 
c File generated by 'pigeonhole', (c) Tjark Weber
c 
c The SAT encoding of this problem is very straightforward.  For each pigeon i
c and each hole j we have a variable x_{n*(i-1)+j} which means that pigeon i
c is placed in hole j.  Then we have n+1 clauses which say that a pigeon has
c to be placed in some hole.  Then for each hole we have a set of clauses
c ensuring that only one single pigeon is placed into that hole.
c 
c This encoding leads to a total of (n+1) * n propositional variables and
c (n+1) + n * (n * (n+1) / 2) clauses.
c 
c The resulting SAT problem is unsatisfiable.
c
c run log
p cnf 12 22
1 2 3 0
4 5 6 0
7 8 9 0
10 11 12 0
-1 -4 0
-1 -7 0
-1 -10 0
-4 -7 0
-4 -10 0
-7 -10 0
-2 -5 0
-2 -8 0
-2 -11 0
-5 -8 0
-5 -11 0
-8 -11 0
-3 -6 0
-3 -9 0
-3 -12 0
-6 -9 0
-6 -12 0
-9 -12 0
c push called, depth = 1`
c --decided to assign 0 to var_1
c push called, depth = 2
c --decided to assign 0 to var_2
c --must assign 1 to var_3 because {1, 2, 3}
c --must assign 0 to var_6 because {-6, -3}
c --must assign 0 to var_12 because {-12, -3}
c --must assign 0 to var_9 because {-3, -9}
c push called, depth = 3
c --decided to assign 0 to var_4
c --must assign 1 to var_5 because {4, 5, 6}
c --must assign 0 to var_8 because {-8, -5}
c --must assign 0 to var_11 because {-5, -11}
c --must assign 1 to var_7 because {8, 9, 7}
c --must assign 1 to var_10 because {10, 11, 12}
c bcp returned false!
c ::zero = [-7, -10]
c pop called, depth = 2
c --must assign 1 to var_4 because {9, 12, 4, 6}
c --must assign 0 to var_10 because {-4, -10}
c --must assign 0 to var_7 because {-7, -4}
c --must assign 1 to var_11 because {10, 11, 12}
c --must assign 1 to var_8 because {8, 9, 7}
c bcp returned false!
c ::zero = [-8, -11]
c pop called, depth = 1
c --must assign 1 to var_4 because {9, 12, 4, 6}  9, 12 get popped, why here
c 当弹出6的时候，我们期望调用{9 12 4 6}的undef，将6变成一个defined的变量，
c 然而，发现6的rev里面并没有这一项
c after-mounted只考虑undef的部分，因此只修改了4的rev，
c 现在4知道了自己是和新学习的句子相关的，
c 然而var 9， 12， 6并不了解自己和新学习的句子相关。
c rev的定义是什么：变量知道所有未被满足的从句。
c 一个已经被决定的变量（将来有可能撤销）是否有权利知道自己有多少未被满足的从句？
c 有的。特别的，如果从来没有加入从句进去，
c 一个变量是否自古以来就知道自己在多少从句中未被满足？
c 必须是这样，因为撤销这个赋值的时候，要利用rev去通知所有从句，where自己被丢在垃圾桶里
c 让他们把自己从垃圾桶里捡出来
c **以上更改已执行！**
c 又再次出现了dic changed during iter
c 原因大概是对变量赋值->导致从句消失->从句在unmount中改变rev
c 因为这个从句想让别的变量知道，自己已经被满足，不需要再管我了
c 但是负责这个从句的这个变量显然不能“不再管”这个从句
c 之前的所谓fix是考虑顺序，使得先做cl.def，因此由于错误的版本里面只考虑undef
c ，就管不到自己了。但事实上是，即使是defined，也得进行考虑。
c 能否通过增加tabu的关系，禁止这个过程访问到自己？
c 已解决！
c --must assign 1 to var_2 because {1, 2}
c --must assign 0 to var_11 because {-11, -2}
c --must assign 0 to var_5 because {-5, -2}
c --must assign 0 to var_10 because {-4, -10}
c --must assign 0 to var_7 because {-7, -4}
c --must assign 0 to var_8 because {-8, -2}
c --must assign 1 to var_9 because {8, 9, 7}
c --must assign 1 to var_12 because {10, 11, 12}
c bcp returned false!
c ::zero = [-12, -9]
c  GET CYCLIC !!